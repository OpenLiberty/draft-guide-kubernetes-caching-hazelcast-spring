// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: caching-microservices-hazelcast
:page-layout: guide
:page-duration: 25 minutes
:page-releasedate: 2019-02-15
:page-description: Explore how to use caching in microservices within Kubernetes environment.
:page-tags: ['Hazelcast', 'Caching', 'microservices', 'Kubernetes', 'Containers','Spring Boot' , 'Minikube']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes-intro']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Caching in microservices with Hazelcast Tutorial
:page-seo-description: How to use Hazelcast with microservices
= Caching Microservices with Hazelcast in Kubernetes

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Use Hazelcast Caching in Open Liberty and Spring Boot based Microservices and deploy to Kubernetes

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:hashtag: #
:win: WINDOWS
:mac: MAC
:linux: LINUX
:hazelcast: Hazelcast


// =================================================================================================
// What you'll learn
// =================================================================================================

== What you'll learn

You will learn how to use Hazelcast distributed caching with Spring Boot, bundle with openliberty and
deploy to a local {kube} cluster.
You will then create a Kubernetes Service which load balance between containers and 
verify that you can share data between Microservices.

The microservice you will deploy is called `hazelcast-caching`. The `hazelcast-caching` microservice simply
helps you put a data and read it back. As Kubernetes Service will send the request to different pod each time 
you initiate the request, the data will be served by shared hazelcast cluster between `hazelcast-caching` pods.
container that it runs in, making it easy to distinguish it from its other replicas. The `ping` microservice

You will use a local single-node {kube} cluster.

== What is {hazelcast}?
Hazelcast is an open source In-Memory Data Grid (IMDG). It provides elastically scalable distributed In-Memory computing, 
widely recognized as the fastest and most scalable approach to application performance.

Hazelcast is designed to scale up to hundreds and thousands of members. 
Simply add new members and they will automatically discover the cluster 
and will linearly increase both memory and processing capacity

=== Why is Spring Boot?
Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
To learn more about Spring Boot. 
http://spring.io/projects/spring-boot

// =================================================================================================
// Prerequisites
// =================================================================================================

include::{common-includes}/kube-prereq.adoc[]

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.


// =================================================================================================
// Staring and preparing your cluster for deployment
// =================================================================================================

include::{common-includes}/kube-start.adoc[]

// =================================================================================================
// Building and containerizing the microservices
// =================================================================================================

== Building and containerizing the microservices

docker images


http://192.168.99.100:31000/put?key=1&value=hazelcast_loves_openliberty
192.168.99.100:31000/get?key=1

explain that data is not shared...



The first step of deploying to {kube} is to build your microservices and containerize them with Docker.

The starting Java project, which you can find in the `start` directory, is a spring boot based microservice.
It is called hazelcast-caching which has two simple endpoints, `/put` and `/get`. This guide uses `boost-maven-plugin` 
to bundle spring boot app and openliberty together and build docker image for the deployment.
Boost plugin does not require you to create your own Dockerfile but instead opionated docker image.

If you wanna learn more about `boost maven plugin`, you can visit the project website.
https://github.com/OpenLiberty/boost/tree/master/boost-maven

If you want to create your own Dockerfile then you can always use dockerfile-maven plugin. 
please refer to https://openliberty.io/guides/kubernetes-intro.html#starting-and-preparing-your-cluster-for-deployment

To build `hazelcast-caching` microservice, navigate to the start directory and run the following command.

[role='command']
```
mvn package
```
This will build the docker image and push it to docker registry provided by minikube. 
execute following command to see available docker images

[role='command']
```
docker images
```

Verify that the `hazelcast-caching:latest` is listed among them, for example:

****
[system]#*{win} | {mac}*#

[source, role="no_copy"]
----
REPOSITORY                                 TAG                 IMAGE ID            CREATED             SIZE
hazelcast-caching                          latest              ee0fb6a53f68        11 seconds ago      595MB
<none>                                     <none>              991f5e8961a5        13 seconds ago      595MB
open-liberty                               springBoot2         1da856d69fac        3 weeks ago         546MB
k8s.gcr.io/kube-proxy-amd64                v1.10.0             bfc21aadc7d3        11 months ago       97MB
k8s.gcr.io/kube-apiserver-amd64            v1.10.0             af20925d51a3        11 months ago       225MB
k8s.gcr.io/kube-scheduler-amd64            v1.10.0             704ba848e69a        11 months ago       50.4MB
k8s.gcr.io/kube-controller-manager-amd64   v1.10.0             ad86dbed1555        11 months ago       148MB
k8s.gcr.io/etcd-amd64                      3.1.12              52920ad46f5b        11 months ago       193MB
k8s.gcr.io/kube-addon-manager              v8.6                9c16409588eb        12 months ago       78.4MB
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64     1.14.8              c2ce1ffb51ed        13 months ago       41MB
k8s.gcr.io/k8s-dns-sidecar-amd64           1.14.8              6f7f2dc7fab5        13 months ago       42.2MB
k8s.gcr.io/k8s-dns-kube-dns-amd64          1.14.8              80cc5ea4b547        13 months ago       50.5MB
k8s.gcr.io/pause-amd64                     3.1                 da86e6ba6ca1        14 months ago       742kB
k8s.gcr.io/kubernetes-dashboard-amd64      v1.8.1              e94d2f21bc0c        14 months ago       121MB
gcr.io/k8s-minikube/storage-provisioner    v1.8.0              4689081edb10        15 months ago       80.8MB
gcr.io/k8s-minikube/storage-provisioner    v1.8.1              4689081edb10        15 months ago       80.8MB
k8s.gcr.io/pause-amd64                     3.0                 99e59f495ffa        2 years ago         747kB
----

[system]#*{linux}*#

[source, role="no_copy"]
----
REPOSITORY                                 TAG                 IMAGE ID            CREATED             SIZE
hazelcast-caching                          latest              ee0fb6a53f68        11 seconds ago      595MB
<none>                                     <none>              991f5e8961a5        13 seconds ago      595MB
open-liberty                               springBoot2         1da856d69fac        3 weeks ago         546MB
k8s.gcr.io/kube-proxy-amd64                v1.10.0             bfc21aadc7d3        11 months ago       97MB
k8s.gcr.io/kube-apiserver-amd64            v1.10.0             af20925d51a3        11 months ago       225MB
k8s.gcr.io/kube-scheduler-amd64            v1.10.0             704ba848e69a        11 months ago       50.4MB
k8s.gcr.io/kube-controller-manager-amd64   v1.10.0             ad86dbed1555        11 months ago       148MB
k8s.gcr.io/etcd-amd64                      3.1.12              52920ad46f5b        11 months ago       193MB
k8s.gcr.io/kube-addon-manager              v8.6                9c16409588eb        12 months ago       78.4MB
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64     1.14.8              c2ce1ffb51ed        13 months ago       41MB
k8s.gcr.io/k8s-dns-sidecar-amd64           1.14.8              6f7f2dc7fab5        13 months ago       42.2MB
k8s.gcr.io/k8s-dns-kube-dns-amd64          1.14.8              80cc5ea4b547        13 months ago       50.5MB
k8s.gcr.io/pause-amd64                     3.1                 da86e6ba6ca1        14 months ago       742kB
k8s.gcr.io/kubernetes-dashboard-amd64      v1.8.1              e94d2f21bc0c        14 months ago       121MB
gcr.io/k8s-minikube/storage-provisioner    v1.8.0              4689081edb10        15 months ago       80.8MB
gcr.io/k8s-minikube/storage-provisioner    v1.8.1              4689081edb10        15 months ago       80.8MB
k8s.gcr.io/pause-amd64                     3.0                 99e59f495ffa        2 years ago         747kB

----
****

If you don't see the `hazelcast-caching:latest` image, then check the Maven build log for any potential errors.
In addition, if you are using Minikube, make sure your Docker CLI is configured to use Minikube's Docker daemon and not your host's as described in the previous section.


// =================================================================================================
// Deploying the microservices
// =================================================================================================

== Deploying the microservices

Now that your Docker images are built, deploy them using a Kubernetes resource definition.
To deploy the `hazelcast-caching` microservice, first create the `kubernetes.yaml` file in the `start` directory:

[source, yaml]
----
include::finish/kubernetes.yaml[tags=**;]
----

This file defines two {kube} resources. It defines one deployment and one service. 
Finally, the `containerPort` is the port that your container exposes for purposes of accessing your application. 
For the services, the key point to understand is that they expose your deployments. The binding between deployments and services is specified by the use of labels -- in this case the `app` label. You will also notice the service has a type of `NodePort`. This means you can access these services from outside of your cluster via a specific port. In this case, the ports will be `31000` and `32000`, but it can also be randomized if the `nodePort` field is not used.

Run the following commands to deploy the resources as defined in kubernetes.yaml:

```
kubectl apply -f kubernetes.yaml
```

run the following command to check the status of your pods:

```
kubectl get pods
```

You'll see an output similar to the following if all the pods are healthy and running:

[source, role="no_copy"]
----
NAME                               READY     STATUS    RESTARTS   AGE
name-deployment-6bd97d9bf6-4ccds   1/1       Running   0          15s
ping-deployment-645767664f-nbtd9   1/1       Running   0          15s
----

You can also inspect individual pods in more detail by running the following command:

```
kubectl describe pods
```

You can also issue the `kubectl get` and `kubectl describe` commands on other {kube} resources, so feel
free to inspect all other resources.

Next you will make requests to your services.

****
[system]#*{win} | {mac}*#

The default hostname for Docker Desktop is `localhost`.

[system]#*{linux}*#

The default hostname for minikube is {minikube-ip}. Otherwise it can be found using the `minikube ip` command.
****

Then `curl` or visit the following URLs to access your microservices, substituting the appropriate hostname:

- {name-api}
- {ping-api}/name-service

The first URL returns a brief greeting followed by the name of the pod that the `name` microservice
runs in. The second URL returns `pong` if it received a good response from the `name-service`
{kube} Service. Visiting `{ping-api}/[kube-service]` in general returns either
a good or a bad response depending on whether `kube-service` is a valid {kube} Service that can be accessed.


== Add Hazelcast and Redeploy microservices

add maven dependencies
do the code change
execute rbac

and show that both pods returning the data

// =================================================================================================
// Scaling with Hazelcast
// =================================================================================================

== Scaling with Hazelcast

Scale the cluster with one more pod and show that you still retrieve the data.

// =================================================================================================
// Testing microservices that are running on {kube}
// =================================================================================================

== Testing microservices that are running on {kube}

Write a simple test similar to THIS
https://github.com/OpenLiberty/guide-kubernetes-intro/blob/master/start/name/src/test/java/it/io/openliberty/guides/name/NameEndpointTest.java


A few tests are included for you to test the basic functionality of the microservices. If a test failure
occurs, then you might have introduced a bug into the code. To run the tests, wait for all pods to be
in the ready state before proceeding further. The default properties defined in the `pom.xml` are:

[cols="15, 100", options="header"]
|===
| *Property*        | *Description*
| cluster.ip        | IP or hostname for your cluster, `{minikube-ip}` by default, which is appropriate when using Minikube.
| name.kube.service | Name of the {kube} Service wrapping the `name` pods, `name-service` by default.
| name.node.port    | The NodePort of the {kube} Service `name-service`, 31000 by default.
| ping.node.port    | The NodePort of the {kube} Service `ping-service`, 32000 by default.
|===

Navigate back to the `start` directory.

****
[system]#*{win} | {mac}*#

Run the integration tests against a cluster running with a hostname of `localhost`:

```
mvn verify -Ddockerfile.skip=true -Dcluster.ip=localhost
```

[system]#*{linux}*#

Run the integration tests against a cluster running at the default Minikube IP address:

```
mvn verify -Ddockerfile.skip=true
```

You can also run the integration tests with an IP address of `192.168.99.100`:

```
mvn verify -Ddockerfile.skip=true -Dcluster.ip=192.168.99.100
```
****

The `dockerfile.skip` parameter is set to `true` in order to skip building a new Docker image.

If the tests pass, you'll see an output similar to the following for each service respectively:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.name.NameEndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.673 sec - in it.io.openliberty.guides.name.NameEndpointTest

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.ping.PingEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.222 sec - in it.io.openliberty.guides.ping.PingEndpointTest

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----


// =================================================================================================
// Tear Down
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed microservices, you can delete all {kube} resources by running the `kubectl delete` command:

```
kubectl delete -f kubernetes.yaml
```


include::{common-includes}/kube-minikube-teardown.adoc[]


// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just created a Spring Boot application, bundled it with openliberty and deployed to {kube}. 
You then added {hazelcast} caching to the `hazelcast-caching`  and ran integration tests against `hazelcast-caching` 
that are running in a {kube} cluster.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
